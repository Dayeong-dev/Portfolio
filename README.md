# 포트폴리오(Portfolio)
작업했던 프로젝트와 경력을 정리해둔 포트폴리오 사이트입니다. <br/>
Vanilla JS(순수 자바스크립트)로 개발했으며, 직접 구현해보는 경험을 쌓고자 시작한 프로젝트입니다.

<br/>

## 🙋‍♀️ 프로젝트 소개
- 개발 기간 : 2024.09 ~ 2025.01
- 프로젝트 유형 : 개인 프로젝트
- 홈페이지 링크 : <https://Dayeong-dev.github.io/Portfolio>

<br/>

## 📚 사용 기술
<img src="https://img.shields.io/badge/JavaScript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black"> <img src="https://img.shields.io/badge/HTML5-E34F26?style=for-the-badge&logo=html5&logoColor=white"> <img src="https://img.shields.io/badge/CSS-1572B6?style=for-the-badge&logo=css3&logoColor=white">

<br/>

## ✨ 주요 기능
1. **원페이지 스크롤 구현**
- 스크롤 시 한 번에 한 섹션씩 이동
- 브라우저 높이 변경 시, 섹션 크기를 조정하고 현재 위치한 섹션의 상단으로 자동 스크롤(현재 위치는 IntersectionObserver API를 활용해 실시간 저장)
- 브라우저 높이가 섹션의 최소 높이보다 작을 경우, 일반 스크롤 방식으로 자동 전환
<br/>

2. **다크모드/라이트모드 테마 변경 구현**
- 헤더에 테마 변경 버튼 추가
- 변경된 테마 상태를 로컬 스토리지에 저장하여, 새로 고침 시 유지
<br/>

3. **슬라이더 구현**
- 슬라이드 개수에 관계없이 별도 수정 없이 동작하도록 구현
- 첫 슬라이드에서는 이전 버튼 비활성화, 마지막 슬라이드에서는 다음 버튼 비활성화
- 이미지 슬라이더의 경우, 페이지네이션 기능으로 현재 이미지 개수 표시
<br/>

4. **프로젝트의 README 내용을 보여주는 모달 창 구현**
- [GitHub REST API](https://docs.github.com/ko/rest?apiVersion=2022-11-28)를 활용하여 해당 레포지토리의 README 데이터를 호출 및 출력
- [github-markdown-css](https://github.com/sindresorhus/github-markdown-css) CDN 적용으로 GitHub 스타일 유지
<br/>

5. **반응형 디자인 적용**
- 모바일, 태블릿, 데스크탑 환경에 맞춰 UI 스타일 최적화
- hover와 pointer 기능을 지원하는 태블릿 이상의 너비를 가진 환경에서만 hover 스타일이 적용
 
<br/>

## 🔥 도전과 해결 과정

#### ❗️첫 번째 난관 : 콘텐츠 크기가 섹션을 초과하는 문제
- 원페이지 스크롤을 적용하면서 각 섹션의 크기를 뷰포트 높이에 맞추다보니, 콘텐츠 크기가 섹션보다 클 경우 일부가 잘리거나 다른 섹션까지 넘어가는 문제가 발생. 

#### 😎 어떻게 해결했는가?
- 섹션의 최소 높이를 `min-height: 680px`로 설정하여, 콘텐츠가 섹션보다 커지는 상황을 방지.

- 만약 뷰포트의 높이가 최소 높이(680px)보다 작을 경우, 원페이지 스크롤이 정상적으로 동작하지 않으므로 일반 스크롤이 적용되도록 구현. 

---

#### ❗️두 번째 난관 : 모바일 브라우저에서 주소 표시줄이 사라지는 문제
- 모바일 환경에서 스크롤 시 주소 표시줄이 사라지고 나타나면서 뷰포트의 높이가 변동되고, 이에 따라 섹션의 높이도 변경되어 UI가 불안정해지고 스크롤이 매끄럽지 않게 되는 문제 발생. 

#### 😎 어떻게 해결했는가?
- 대부분의 모바일 브라우저에서 html과 body의 스크롤이 감지될 때 주소 표시줄이 사라지는 동작이 발생하는 것을 확인.

- 주소 표시줄이 사라지지 않고 유지되면서도 스크롤 기능이 정상적으로 동작하도록 개선.
  * html과 body에 `overflow-y: hidden`를 적용하여 전체 스크롤을 방지.
  * body 내부에 모든 콘텐츠를 포함하는 `div` 요소를 추가하고, 해당 `div` 요소에 `overflow-y: auto`를 적용하여 내부에서만 스크롤이 가능하도록 구현.  

---

#### ❗️세 번째 난관 : 브라우저 높이 변경 시 잘못된 섹션 이동 문제
- 뷰포트 높이가 최소 높이(680px) 이하일 때 일반 스크롤을 적용하는 과정에서, '**브라우저 크기 변경 시 섹션 크기를 재조정한 후 현재 위치한 섹션의 상단으로 자동 스크롤하는 기능**'이 원활하게 작동하지 않는 문제가 발생.

- 일반 스크롤 상태에서는 현재 섹션을 실시간으로 확인할 수 없어, 브라우저 크기 변경 시 현재 위치한 섹션이 아닌 다른 섹션으로 이동하는 문제가 발생.

#### 😎 어떻게 해결했는가?
- `IntersectionObserver API`를 활용하여 일반 스크롤 시에도 현재 위치한 섹션을 실시간으로 감지하고 저장하는 방식을 적용.

- `scrollTop()`을 이용하여 휠 이벤트 발생 시 마다 현재 섹션 위치를 계산하여 저장하는 방식도 고려했으나, 불필요한 이벤트 호출이 많아 성능 저하 가능성이 있었음.
  * 디바운스나 스로틀을 적용하여 성능 저하를 줄일 수 있도록 시도했으나, 일정 시간 내에 다른 이벤트(브라우저 크기 변경이나 추가적인 스크롤)가 발생하면 이벤트가 충돌하여 섹션 위치가 정확하게 계산되지 않는 문제가 발생.

---

#### ❗️네 번째 난관 : 터치패드 스크롤 시 한 번에 여러 섹션이 이동하는 문제
- 노트북 터치패드 사용 시, 사용이 끝난 후에도 휠 이벤트가 계속 발생하여 원치 않는 추가 스크롤이 발생.

- 일반 마우스 휠은 `deltaY` 값이 일정하게 유지되지만, 터치패드 사용 시에는 가속도에 따라 `deltaY` 값이 **점진적으로 커졌다가 다시 작아지는 패턴**으로 휠 이벤트가 발생.
  * 예: 1 → 2 → 4 → ... → 100 → ... → 4 → 2 → 1

- 이로 인해 일정 시간 동안 발생한 여러 개의 휠 이벤트를 하나의 이벤트로 처리하는 구조에서, 휠 이벤트가 지정된 시간을 초과하여 발생하는 경우 원치 않는 추가 스크롤이 발생하게 되는 것을 확인

#### 😎 어떻게 해결했는가?
- 디바운스를 적용하여 가장 처음 발생한 이벤트를 실행한 후, 일정 시간 동안 추가적인 이벤트가 없을 때만 새로운 스크롤 이벤트를 허용하도록 작성.
  
- 휠 가속도가 증가하는 경우에만(직전 `deltaY`의 절댓값(`preDeltaY`)보다 현재의 `deltaY`의 절댓값이 클 때만) 디바운스 이벤트를 호출.
  * 가속도가 감소하는 시점부터는 디바운스 이벤트를 호출하지 않도록 하여 다음 스크롤 이벤트를 더 빠르게 허용하고 자연스러운 스크롤이 가능하도록 최적화.

- 추가로 별도의 디바운스를 적용하여 일정 시간 동안 휠 이벤트가 감지되지 않으면 `prevDeltaY` 값을 0으로 초기화 하고, 이를 통해 새로운 스크롤 이벤트를 원활하게 감지할 수 있도록 개선. 

<br/>

## 📖 느낀점
저는 이번 프로젝트를 기획하면서 '내 포트폴리오 사이트만큼은 내가 개발해보고 싶었던 것들을 구현해보자!'라는 생각을 가지고 임했습니다. 
그만큼 개발 과정에서 예상보다 많은 어려움을 겪었지만, 문제를 해결하는 과정 자체가 재미있는 경험이었습니다.

특히, Vanilla JS로 개발해보는 것과 원페이지 스크롤을 직접 구현해보는 것이 가장 해보고 싶었던 부분이었는데요. 
원페이지 스크롤 기능은 레퍼런스에서 볼 때와 달리 생각보다 훨씬 복잡한 기능이었고, 다양한 문제와 오류를 경험하게 해주었습니다. 

그 중에서도 가장 어려웠던 경험을 뽑자면 **노트북 터치패드 사용 시 한 번의 스크롤로 여러 섹션이 이동하는 문제**를 해결할 때 였습니다. 
조사를 해보니 마우스와 터치패드의 휠 이벤트 발생 방식이 다르다는 것을 알게 되었고, 이를 해결하기 위해 두 방식 모두에 기능이 제대로 작동할 수 있도록 코드를 수정해야 했습니다. 
이 과정에서 원페이지 스크롤 기능의 동작 원리를 더 깊이 이해할 수 있었고, 다양한 예제 코드들을 분석하면서 Vanilla JS 개발에도 좀 더 익숙해질 수 있었습니다.

이번 프로젝트를 통해 단순히 기능을 구현하는 것뿐만 아니라, 예상치 못한 문제를 해결하는 과정에서 많은 것을 배울 수 있어 좋은 경험이었다고 생각합니다.

<br/>
